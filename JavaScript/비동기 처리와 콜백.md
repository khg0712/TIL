## 콜백

콜백 함수는 함수의 인자로 전달되는 함수를 말한다. 

```js
setTimeout(function() {
    console.log(1);
},1000);
```

위 코드는 우리가 자주 쓰는 콜백 함수다. 위에서 보면 알 수 있듯이 함수의 인자로 나중에 사용할 함수를 전달받아서 사용한다. 콜백 함수는 다른 함수와 다른 것이 없다. 콜백 함수는 다른 함수와 마찬가지로 똑같은 자바스크립트 함수이다. 일반적으로 콜백은 익명함수로 사용한다.

보통 콜백 함수를 사용하는 이유는 비동기적으로 코드를 작성해야 하는 상황이기 때문이다. setTimeout 함수도 비동기 함수의 예시이다. 비동기 함수의 특징을 잘 나타내는 코드를 보자.

```js
console.log('Before setTimeout()!');
function a() {
    console.log('callBack is done!');
}
setTimeout(a, 1000);
console.log('After setTimeout()!');
```

위 코드를 실행해보면 예상과 다른 결과가 나올 것이다. 우리는 일반적으로 순차적인 실행을 하는 코드에 익숙하다. 하지만 위 코드를 실행해보면 순차적으로 실행될 것 이라는 예상과 다르게 아래와 같이 출력된다.

![callback 함수 결과](./pictures/callback.png)

이렇게 순차적이지 않다는 것이 바로 비동기적 실행의 특징이다. 비동기적 실행의 장점은 한 구문을 실행하는 데 모든 자원을 사용하지 않는다는 것이다. 하고 있는 작업보다 먼저 처리할 수 있는 작업이 있다면 그 작업을 먼저 처리하는 방식은 비동기적 실행의 가장 좋은 점이다.

자바스크립트는 싱글 스레드를 사용하기 때문에, 60초 동안 대기하라는 코드를 동기적으로 실행하게 되면, 다른 코드들까지 저 동작을 위해 기다리게 되어 자원의 낭비가 발생하게 된다. 이런 현상은 UX적으로 매우 좋지 않은 상황이라고 할 수 있다. 하지만 비동기적 실행을 하게 된다면 이런 현상을 해결할 수 있다. 아래에 동기적 실행의 나쁜 예시를 보면 비동기적 실행의 필요성을 알 수 있다.

```js
console.log('Before Loading!');
function loading() {
    var b = 0;
    for(var a=0 ; a<5000000000 ; a++) {
        b++;
    }
    console.log('loading is done');
}
loading();
console.log('After Loading!');
```

보통 콜백 함수에 넘기는 함수는 이름이 없는 익명 함수를 사용한다.

## 스코프와 비동기적 실행

비동기적 실행에서 어려운 점은 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이다.함수를 호출하면 항상 `클로저`가 만들어진다. 매개변수를 포함한 함수내에서 생성된 변수는 모두 무언가가 자신에게 접근할 수 있는 한 `클로저`는 계속 존재한다.

아래 예제는 이전에 클로저 파트에서 봤었지만, 다시 한 번 countdown 함수에 대해서 생각해보자.

```js
function countdown() {
  let i;
  console.log('Count down!');
  for(i=5; i>=0; i--) {
    setTimeout(function() {
      console.log(i===0 ? "GO!" : i);
    }, (5-i)*1000);
  }
}
countdown();
```

위 코드의 동작을 보면 1초마다 -1이 6번 출력된다. 코드를 보면 5부터 카운트다운 할 것 같지만 실제로는 그렇지 않다. 이 예제는 원래 var을 통해서 변수 i를 선언해서 let을 통해서 변수를 선언하면 이 문제를 해결할 수 있었지만, 이 예제에서는 i를 for 루프 바깥에서 선언했으므로 똑같은 문제가 발생하게 된다.

이 문제가 발생하는 이유는 `countdown`이 호출될 때, 변수 i가 들어있는 클로저가 발생하게 된다. 이때, for 루프 안에서 만드는 콜백은 모두 i에 접근할 수 있는데, 각각의 콜백이 접근하는 i는 똑같은 i이다.

여기서 주의깊게 봐야 하는 부분은 for 루프안에서 i를 두 가지 방법으로 사용했다는 것이다. `setTimeout`의 콜백 함수에서 호출한 i와 `setTimeout`의 인자로 들어간 타임아웃을 계산하기 위한 i가 있다. 여기서 타임아웃을 계산할 때 사용된 i는 제대로 들어갔다.(첫 번째 타임아웃은 0, 두 번째 타임아웃은 1000, 세 번째 타임아웃은 2000...) 이 이유는 바로 `setTimeout`은 동기적으로 실행되기 때문이다. 비동기적인 부분은 `setTimeout`에 전달된 콜백 함수이다.

이 문제는 `즉시 호출 함수 표현식(IIFE)`으로 해결할 수 있고, i를 for 루프 안에서 선언하는 방식으로 해결할 수 있다.

```js
function countdown() {
  console.log('Count down!');
  for(let i=5; i>=0; i--) {
    setTimeout(function() {
      console.log(i===0 ? "GO!" : i);
    }, (5-i)*1000);
  }
}
countdown();
```

여기서 let을 for 루프 안에서 선언했을 때와 바깥에 선언했을 때 이 두 상황에서의 차이는 이렇게 말할 수 있다. 먼저 for 루프 바깥에서 i를 선언했을 때에는 setTimeout의 콜백 함수에서 참조하는 i는 for루프가 이미 다 끝난 상태의 i이다. 하지만 for 루프 안에서 선언된 i는 각각의 **루프**마다 **독립적인 스코프**를 가지기 때문에 콜백 함수는 **클로저**를 형성하게 된다. 따라서 콜백에서 쓰이는 i의 값은 매 루프에서 콜백이 실행될 때 마다 다를 수 있다.