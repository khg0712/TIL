## 콜백

콜백 함수는 함수의 인자로 전달되는 함수를 말한다. 

```js
setTimeout(function() {
    console.log(1);
},1000);
```

위 코드는 우리가 자주 쓰는 콜백 함수다. 위에서 보면 알 수 있듯이 함수의 인자로 나중에 사용할 함수를 전달받아서 사용한다. 콜백 함수는 다른 함수와 다른 것이 없다. 콜백 함수는 다른 함수와 마찬가지로 똑같은 자바스크립트 함수이다. 일반적으로 콜백은 익명함수로 사용한다.

보통 콜백 함수를 사용하는 이유는 비동기적으로 코드를 작성해야 하는 상황이기 때문이다. setTimeout 함수도 비동기 함수의 예시이다. 비동기 함수의 특징을 잘 나타내는 코드를 보자.

```js
console.log('Before setTimeout()!');
function a() {
    console.log('callBack is done!');
}
setTimeout(a, 1000);
console.log('After setTimeout()!');
```

위 코드를 실행해보면 예상과 다른 결과가 나올 것이다. 우리는 일반적으로 순차적인 실행을 하는 코드에 익숙하다. 하지만 위 코드를 실행해보면 순차적으로 실행될 것 이라는 예상과 다르게 아래와 같이 출력된다.

![callback 함수 결과](./pictures/callback.png)

이렇게 순차적이지 않다는 것이 바로 비동기적 실행의 특징이다. 비동기적 실행의 장점은 한 구문을 실행하는 데 모든 자원을 사용하지 않는다는 것이다. 하고 있는 작업보다 먼저 처리할 수 있는 작업이 있다면 그 작업을 먼저 처리하는 방식은 비동기적 실행의 가장 좋은 점이다.

자바스크립트는 싱글 스레드를 사용하기 때문에, 60초 동안 대기하라는 코드를 동기적으로 실행하게 되면, 다른 코드들까지 저 동작을 위해 기다리게 되어 자원의 낭비가 발생하게 된다. 이런 현상은 UX적으로 매우 좋지 않은 상황이라고 할 수 있다. 하지만 비동기적 실행을 하게 된다면 이런 현상을 해결할 수 있다. 아래에 동기적 실행의 나쁜 예시를 보면 비동기적 실행의 필요성을 알 수 있다.

```js
console.log('Before Loading!');
function loading() {
    var b = 0;
    for(var a=0 ; a<5000000000 ; a++) {
        b++;
    }
    console.log('loading is done');
}
loading();
console.log('After Loading!');
```

보통 콜백 함수에 넘기는 함수는 이름이 없는 익명 함수를 사용한다.

## 스코프와 비동기적 실행

비동기적 실행에서 어려운 점은 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이다.함수를 호출하면 항상 `클로저`가 만들어진다. 매개변수를 포함한 함수내에서 생성된 변수는 모두 무언가가 자신에게 접근할 수 있는 한 `클로저`는 계속 존재한다.

아래 예제는 이전에 클로저 파트에서 봤었지만, 다시 한 번 countdown 함수에 대해서 생각해보자.

```js
function countdown() {
  let i;
  console.log('Count down!');
  for(i=5; i>=0; i--) {
    setTimeout(function() {
      console.log(i===0 ? "GO!" : i);
    }, (5-i)*1000);
  }
}
countdown();
```

위 코드의 동작을 보면 1초마다 -1이 6번 출력된다. 코드를 보면 5부터 카운트다운 할 것 같지만 실제로는 그렇지 않다. 이 예제는 원래 var을 통해서 변수 i를 선언해서 let을 통해서 변수를 선언하면 이 문제를 해결할 수 있었지만, 이 예제에서는 i를 for 루프 바깥에서 선언했으므로 똑같은 문제가 발생하게 된다.

이 문제가 발생하는 이유는 `countdown`이 호출될 때, 변수 i가 들어있는 클로저가 발생하게 된다. 이때, for 루프 안에서 만드는 콜백은 모두 i에 접근할 수 있는데, 각각의 콜백이 접근하는 i는 똑같은 i이다.

여기서 주의깊게 봐야 하는 부분은 for 루프안에서 i를 두 가지 방법으로 사용했다는 것이다. `setTimeout`의 콜백 함수에서 호출한 i와 `setTimeout`의 인자로 들어간 타임아웃을 계산하기 위한 i가 있다. 여기서 타임아웃을 계산할 때 사용된 i는 제대로 들어갔다.(첫 번째 타임아웃은 0, 두 번째 타임아웃은 1000, 세 번째 타임아웃은 2000...) 이 이유는 바로 `setTimeout`은 동기적으로 실행되기 때문이다. 비동기적인 부분은 `setTimeout`에 전달된 콜백 함수이다.

이 문제는 `즉시 호출 함수 표현식(IIFE)`으로 해결할 수 있고, i를 for 루프 안에서 선언하는 방식으로 해결할 수 있다.

```js
function countdown() {
  console.log('Count down!');
  for(let i=5; i>=0; i--) {
    setTimeout(function() {
      console.log(i===0 ? "GO!" : i);
    }, (5-i)*1000);
  }
}
countdown();
```

여기서 let을 for 루프 안에서 선언했을 때와 바깥에 선언했을 때 이 두 상황에서의 차이는 이렇게 말할 수 있다. 먼저 for 루프 바깥에서 i를 선언했을 때에는 setTimeout의 콜백 함수에서 참조하는 i는 for루프가 이미 다 끝난 상태의 i이다. 하지만 for 루프 안에서 선언된 i는 각각의 **루프**마다 **독립적인 스코프**를 가지기 때문에 콜백 함수는 **클로저**를 형성하게 된다. 따라서 콜백에서 쓰이는 i의 값은 매 루프에서 콜백이 실행될 때 마다 다를 수 있다.

## 콜백 헬

콜백을 사용해서 비동기 처리를 할 수 있지만, 여기에는 큰 문제가 하나있다. 한 번에 여러가지 작업을 기다려야 한다면 콜백들을 관리하기 까다로워진다. 세 개의 파일을 읽고, 60초가 지난 이후에 각각의 내용을 결합해서 네 번째 파일에 기록하는 노드 앱을 작성해보자.

```js
const fs = require('fs');

fs.readFile('a.txt', function(err, dataA) {
    if(err) console.error(err);
    fs.readFile('b.txt', function(err, dataB) {
        if(err) console.error(err) ;
        fs.readFile('c.txt', function(err, dataC) {
            if(err) console.error(err);
            setTimeout(function() {
                fs.writeFile('d.txt', dataA+dataB+dataC, function(err) {
                    if(err) console.error(err);
                });
        }, 1000);
    });
});
```

위 코드같이 콜백 함수가 엮이고 엮인 코드를 **콜백 헬**이라고 말한다. 위 코드에서는 에러를 기록하기만 했지만, 예외를 일으키려고 했다면 더 힘들었을 것이다.

```js
const fs = require('fs');
function readSketchyFile() {
    try {
        fs.readFile('does_not_exist.txt', function(error, data) {
            if(error) throw error;
        });
    } catch(error) {
        console.log("Error!!!!!");
    }
}

readSketchyFile();
```

위 코드는 node가 파일을 읽어들이지 못하는 예외 사항을 처리할 수 있을 것처럼 보이지만 readFile은 비동기 처리 함수이기 때문에 콜백에서 발생하는 예외사항을 잡아낼 수 없다.

그리고, 콜백이 우연히 두 번 호출되거나, 아예 호출되지 않는 경우를 방지하는 안전장치도 존재하지 않는다. 콜백이 정확히 한 번만 호출될 것을 가정하고 코드를 작성한다면 된다고 생각하고 있다면 자바스크립트는 그런 걸 보장하지 않는 다는 것을 알아둬야 한다.

이런 비동기처리를 위한 콜백을 포함한 코드가 늘어나면 늘어날수록 버그가 없고 관리하기 쉬운 코드는 작성하기 어려워진다. 그래서 이 문제를 해결하기 위해 `프로미스`가 등장하게 됐다.

이에 관한 [글](https://ruben.verborgh.org/blog/2012/12/31/asynchronous-error-handling-in-javascript/)을 읽어보는 것을 추천한다.