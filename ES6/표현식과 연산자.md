## 산술 연산자

| 연산자 | 설명 | 사용 예시 |
|:-----:|:----:|:--------:|
| + | 덧셈 | 3 + 2 |
| - | 뺄셈 | 3 - 2 |
| / | 나눗셈 | 3 / 2 |
| * | 곱셈 | 3 * 2 |
| % | 나머지 | 3 % 2 |
| - | 단항 부정 | -a |
| + | 단항 플러스 | +a |
| ++ | 전위 증가 | ++a //a의 값에 1을 더한 후에 값 평가 |
| ++ | 후위 증가 | a++ //a의 값을 평가한 후에 1을 더함|
| -- | 전위 감소 | --a //a의 값에 1을 뺀 이후에 값 평가|
| -- | 후위 감소 | a-- //a의 값을 평가한 이후에 1을 뺌|

위에서 보이는 자바스크립트의 산술 연산자는 다른 프로그래밍 언어의 산술 연산자와 크게 다른게 없다. 

눈에 띄는 게 있다면 뺄셈과 단항 부정, 덧셈과 단항 플러스의 연산자가 똑같다는 것이다. 만약 이 같은 형태의 연산자를 같이 쓰게 되면 어떻게 될까? 이 때에는 단항 부정이 먼제 연산되고 그 이후에 뺄셈이 이뤄진다.(사실 뭐가 먼저 이뤄지든 결과는 같다.) 단항 플러스도 이와 같은 규칙이 적용된다.

```
let a = 5;
let b = a - -2; //7
```

보통 단항 플러스와 단항 부정은 문자열을 숫자로 타입 변환할 때 사용한다. 

```
let str = "4";
let num1 = 3 + +str; //단항 플러스를 사용하지 않았다면
                    // 문자열 병합이 일어나 num1에는 "34"가 할당된다.
```

### 후위 연산자

전위 연산자는 해당 변수에 바로 적용되는 연산자이기 때문에 어떤 상황에서도 우리가 생각하는 대로 값이 정해질 것이다. 다만, 후위 연산자는 특수한 상황에서 우리가 예상한 결과와 다른 결과가 나올 수 있다.

```
let num = 1;
let result = num++ + num++;
console.log(num);
```

위 예시에서 result의 값은 3이 된다. 그 이유는 앞에서 연산자들을 설명한 글을 보면 간단하다. 후위 연산자는 변수가 평가된 이후에 변수에 1을 더하거나 뺀다. 따라서 위의 예제를 실제 동작대로 표현해보면 아래와 같다.

```
let num = 1;
let result = num++ + num++;
//          1 + num++;
//          num += 1;
//          1 + 2;
//          num += 1;

console.log(num); //3 출력
```

## 단축 평가

논리 연산을 진행할 때, OR 연산을 할 때, 앞의 조건의 결과가 true 라면 뒤의 조건은 평가할 필요없이 해당 연산의 결과는 true이다. 자바스크립트는 논리 연산을 할 때 이렇게 동작합니다. 이런 동작을 단축 평가(short-circuit evaluation)라고 한다.

단축 평가가 중요한 이유는 바로 위의 예시에서 두 번째 조건(피연산자)에 부수 효과가 있더라도 단축 평가로 무시되기 때문이다. 예제를 통해서 잘 알아보자.

```
let condition = true;
let k = 0;
let result = condition || k++;
console.log(k); //0 출력
```

위의 코드를 보면 condition의 값이 true이기 때문에 3번째 행에서 단축 평가가 일어난다. 따라서 k++라는 표현식은 실행되지 않고 해당 식은 true로 판별된다.

## 논리 연산자의 다른 동작

논리 연산자의 피연산자로 불리언 타입 데이터를 사용하면 논리 연산자는 항상 불리언을 반환한다.(두 개의 피연산자 모두가 불리언 타입일 때) 하지만 두 개의 피연산자가 모두 불리언이 아닌 상황에서 논리 연산자는 불리언이 아닌 결과를 결정하는 피연산자를 반환한다.

> 앞으로 truthy한 값은 불리언 타입으로 변환됐을 때 true가 되는 데이터를 나타내고 falsy한 값은 불리언 타입으로 변환됐을 때 false가 되는 데이터를 나타낸다.

truthy한 값과 falsy한 값의 종류들을 알려주는 [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) 관련 링크를 참고해라.

| x | y | x && y |
|:--|:--|:-------|
| falsy한 값 | falsy한 값 | x (첫 번째 피연산자) |
| falsy한 값 | truthy한 값 | x (첫 번째 피연산자) |
| truthy한 값 | falsy한 값 | y (두 번째 피연산자) |
| truthy한 값 | truthy한 값 | y (두 번째 피연산자) |

| x | y | x \|\| y |
|:--|:--|:---------|
| falsy한 값 | falsy한 값 | y (두 번째 피연산자) |
| falsy한 값 | truthy한 값 | y (두 번째 피연산자) |
| truthy한 값 | falsy한 값 | x (첫 번째 피연산자) |
| truthy한 값 | truthy한 값 | x (첫 번째 피연산자) |

논리 연산자의 피연산자들 중 하나라도 불리언 타입이 아니라면 결과는 위 표처럼 반환된다. 이 패턴을 잘 활용하면 간략하게 코드를 짜는데 도움이 될 것이다.

```
let options = suppliedOptions || { name:"default" };
```

위 코드에서 상황이 suppliedOptions에 객체가 담겨있다면 option은 suppliedOption를 가리키게 된다.(객체는 모두 truthy한 값이다. 빈 객체도 마찬가지!) 하지만 suppliedOption에 undefined나 null이 담겨있다면 falsy한 값이므로 options는 두 번째 피연산자 즉, 기본 객체를 가리키게 된다.

NOT 논리 연산자는 불리언 타입이 아닌 값을 반환할 수 없으므로 ! 연산자의 반환값은 **항상 불리언 타입**이다.

## 쉼표 연산자

쉼표 연산자는 표현식을 결합해서 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환한다. 보통 for 루프에서 여러 개의 변수들을 다룰 때 사용한다.

```
let x = 1;
let y = (x++,x++); //2
```
위 코드에서 괄호를 쓰지 않았다면 쉼표 연산자는 우선순위가 가장 낮은 연산자이므로 y에는 x++의 결과인 1이 저장되고 그다음에 추가적으로 x++가 실행됐을 것이다.

```
for (var i = 0, j = 9; i <= j; i++, j--)
  console.log(`i: ${i}, j: ${j}`);
```

## 해체 할당

해체 할당(distructuring assignment)은 ES6에서 새로 생긴 기능입니다. 매우 편리한 기능으로 실제 코드 작성시 많이 사용할 것 같습니다. 이 기능은 객체나 배열을 변수로 해체할 수 있습니다. 객체 해체 할당을 코드로 알아보자.

```
let obj = {
    a: 24,
    b: 12,
    d: 6
};

const {a,b,c} = obj;
console.log(a); //24
console.log(b); //12
console.log(c); //undefined
console.log(d); //Uncaught ReferenceError: d is not defined
```